<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MiniCorp â€” Boss Timer</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0a0a0a">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: 'class' };</script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Inter", system-ui, sans-serif; zoom: 1.0625; }
    .boss-img, .deck-img { display: none !important; }
    .countdown-mono { font-variant-numeric: tabular-nums; }
    textarea { resize: none; }
    textarea::-webkit-scrollbar { width: 6px; }
    textarea::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
    .dark textarea::-webkit-scrollbar-thumb { background: #475569; }
    .boss-card { transition: transform 80ms ease, box-shadow 80ms ease; padding: 8px !important; }
    .boss-card:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.06); z-index: 2; }
    .dark .boss-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
    .boss-img { width: 36px; height: 36px; border-radius: 8px; object-fit: cover; background: #e5e7eb; flex-shrink: 0; }
    .dark .boss-img { background: #374151; }
    .deck-card {
      width: 180px; min-height: 240px; border-radius: 12px; flex-shrink: 0;
      background: white; border: 1px solid #d1d5db;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      transition: transform 160ms ease, box-shadow 160ms ease;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      padding: 14px 10px; gap: 6px; cursor: default; position: relative;
    }
    .dark .deck-card { background: #171717; border-color: #333; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .deck-card:hover { transform: translateY(-8px); box-shadow: 0 12px 28px rgba(0,0,0,0.15); z-index: 10; }
    .dark .deck-card:hover { box-shadow: 0 12px 28px rgba(0,0,0,0.5); }
    .deck-card.urgent { border-color: #f87171; }
    .deck-card.soon-card { border-color: #60a5fa; }
    .deck-img { width: 72px; height: 72px; border-radius: 10px; object-fit: cover; background: #f3f4f6; }
    .kill-btn {
      font-size: 11px; padding: 4px 10px; border-radius: 6px;
      background: #fee2e2; color: #b91c1c; border: 1px solid #fca5a5;
      cursor: pointer; transition: background 120ms; font-weight: 500;
    }
    .kill-btn:hover { background: #fecaca; }
    .dark .kill-btn { background: #371717; color: #fca5a5; border-color: #7f1d1d; }
    .dark .kill-btn:hover { background: #4c1d1d; }
    .set-btn {
      font-size: 11px; padding: 4px 10px; border-radius: 6px;
      background: #dbeafe; color: #1d4ed8; border: 1px solid #93c5fd;
      cursor: pointer; transition: background 120ms; font-weight: 500;
    }
    .set-btn:hover { background: #bfdbfe; }
    .dark .set-btn { background: #172554; color: #93c5fd; border-color: #1e3a5f; }
    .dark .set-btn:hover { background: #1e3a5f; }
    .manual-time-input {
      font-size: 11px; padding: 2px 6px; border-radius: 5px; height: 26px;
      border: 1px solid #d1d5db; background: white; color: #374151; outline: none;
    }
    .dark .manual-time-input { border-color: #404040; background: #262626; color: #d1d5db; }
    .dark .deck-img { background: #262626; }
    .deck-scroll { display: flex; gap: 10px; overflow-x: auto; padding: 8px 2px 12px; scroll-snap-type: x proximity; }
    .deck-scroll.dragging { cursor: grabbing; user-select: none; -webkit-user-select: none; }
    .deck-scroll.dragging .deck-card:hover { transform: none !important; box-shadow: none !important; z-index: 0 !important; }
    .deck-scroll.dragging .deck-card { transition: none !important; }
    .deck-scroll > * { scroll-snap-align: start; }
    .deck-scroll::-webkit-scrollbar { height: 4px; }
    .deck-scroll::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 2px; }
    .dark .deck-scroll::-webkit-scrollbar-thumb { background: #404040; }
    .admin-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 100; display: flex; align-items: center; justify-content: center; }
    .admin-modal { background: white; border-radius: 12px; padding: 24px; width: 320px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
    .dark .admin-modal { background: #1a1a1a; border: 1px solid #333; }
    .admin-input { width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px; outline: none; background: white; color: #111; }
    .dark .admin-input { border-color: #404040; background: #262626; color: #e5e5e5; }
    .admin-input:focus { border-color: #6366f1; box-shadow: 0 0 0 2px rgba(99,102,241,0.2); }
    .admin-submit { width: 100%; padding: 8px; border-radius: 8px; background: #4f46e5; color: white; font-weight: 600; font-size: 14px; cursor: pointer; border: none; margin-top: 12px; }
    .admin-submit:hover { background: #4338ca; }
    .admin-error { color: #ef4444; font-size: 12px; margin-top: 6px; display: none; }
    .admin-badge { font-size: 10px; padding: 2px 8px; border-radius: 999px; background: #eef2ff; color: #4f46e5; font-weight: 600; }
    .dark .admin-badge { background: #312e81; color: #a5b4fc; }
    .spawn-overlay {
      position: fixed; inset: 0; z-index: 200;
      background: rgba(0,0,0,0.85);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      opacity: 0; pointer-events: none; transition: opacity 200ms;
    }
    .spawn-overlay.active { opacity: 1; pointer-events: auto; }
    .spawn-overlay .spawn-boss-name {
      font-size: 1.2rem; font-weight: 600; color: #94a3b8; margin-bottom: 8px;
      text-transform: uppercase; letter-spacing: 0.1em;
    }
    .spawn-overlay .spawn-number {
      font-size: 8rem; font-weight: 900; color: white;
      font-variant-numeric: tabular-nums;
      animation: spawn-pulse 1s ease-out;
      line-height: 1;
    }
    .spawn-overlay .spawn-number.spawned {
      font-size: 3.5rem; color: #f87171;
      animation: spawn-flash 0.6s ease-out;
    }
    .spawn-overlay .spawn-sub {
      font-size: 0.9rem; color: #64748b; margin-top: 12px;
    }
    @keyframes spawn-pulse {
      0% { transform: scale(1.6); opacity: 0.3; }
      50% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0.95); opacity: 0.9; }
    }
    @keyframes spawn-flash {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    .filter-bar { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .filter-bar input {
      height: 32px; padding: 0 10px; border-radius: 8px; font-size: 12px;
      border: 1px solid #d1d5db; background: white; color: #374151; outline: none; width: 180px;
    }
    .dark .filter-bar input { border-color: #404040; background: #171717; color: #d1d5db; }
    .filter-bar input:focus { border-color: #6366f1; box-shadow: 0 0 0 2px rgba(99,102,241,0.15); }
    .timeline-wrap { position: relative; padding: 12px 0 20px; overflow-x: auto; }
    .timeline-bar {
      position: relative; height: 4px; background: #e5e7eb; border-radius: 2px; min-width: 100%;
    }
    .dark .timeline-bar { background: #333; }
    .timeline-marker {
      position: absolute; top: -8px; width: 20px; height: 20px; border-radius: 50%;
      background: #6366f1; border: 2px solid white; transform: translateX(-50%);
      display: flex; align-items: center; justify-content: center;
      font-size: 8px; font-weight: 700; color: white; cursor: default;
      transition: transform 120ms;
    }
    .dark .timeline-marker { border-color: #171717; }
    .timeline-marker:hover { transform: translateX(-50%) scale(1.3); z-index: 5; }
    .timeline-marker.urgent-marker { background: #ef4444; }
    .timeline-marker.soon-marker { background: #3b82f6; }
    .timeline-label {
      position: absolute; top: 18px; transform: translateX(-50%); white-space: nowrap;
      font-size: 9px; color: #9ca3af; pointer-events: none;
    }
    .dark .timeline-label { color: #6b7280; }
    .timeline-now {
      position: absolute; top: -10px; width: 2px; height: 24px;
      background: #f59e0b; transform: translateX(-50%);
    }
    .timeline-now-label {
      position: absolute; top: 16px; transform: translateX(-50%); font-size: 8px;
      color: #f59e0b; font-weight: 600; white-space: nowrap;
    }
    .mute-btn svg { width: 16px; height: 16px; }

    /* Sync indicator */
    .sync-dot { width: 7px; height: 7px; border-radius: 50%; background: #22c55e; display: inline-block; margin-right: 4px; }
    .sync-dot.syncing { background: #f59e0b; animation: pulse-dot 1s infinite; }
    .sync-dot.error { background: #ef4444; }
    @keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:0.3} }
  </style>
</head>
<body class="min-h-screen bg-gray-50 dark:bg-neutral-950 text-gray-900 dark:text-gray-100 transition-colors duration-200">
  <div class="max-w-6xl mx-auto px-5 py-8">

    <!-- Header -->
    <div class="flex flex-col gap-2 mb-6">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <h1 class="text-lg font-semibold tracking-tight">Boss Timer</h1>
          <span class="px-1.5 py-0.5 text-[10px] font-bold uppercase tracking-wider rounded bg-amber-100 text-amber-700 dark:bg-amber-900/40 dark:text-amber-400 leading-none">Beta</span>
          <a href="relic.html" class="text-xs text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition">Relic Calc &rarr;</a>
          <a href="potion.html" class="text-xs text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition">Potion Calc &rarr;</a>
        </div>
        <div class="flex items-center gap-3">
          <span class="text-sm font-bold tracking-tight text-gray-800 dark:text-gray-200">MiniCorp</span>
          <!-- Sync status -->
          <span id="sync-status" class="flex items-center text-xs text-gray-400 dark:text-gray-500">
            <span class="sync-dot syncing" id="sync-dot"></span>
            <span id="sync-label">Loading...</span>
          </span>
          <span id="status-pill" class="text-xs text-gray-400 dark:text-gray-500">Waiting for input</span>
          <span id="admin-badge" class="admin-badge hidden">Admin</span>
          <button id="toggle-admin" class="w-8 h-8 flex items-center justify-center rounded-lg text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-neutral-800 transition" title="Admin login">
            <svg id="icon-lock" class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0110 0v4"/></svg>
            <svg id="icon-unlock" class="w-4 h-4 hidden" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 019.9-1"/></svg>
          </button>
          <button id="toggle-theme" class="w-8 h-8 flex items-center justify-center rounded-lg text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-neutral-800 transition" title="Toggle theme">
            <svg id="icon-sun" class="w-4 h-4 hidden" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
            <svg id="icon-moon" class="w-4 h-4 hidden" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
          </button>
        </div>
      </div>
      <!-- Options row -->
      <div class="flex items-center gap-3 text-xs">
        <label for="layout-mode" class="text-gray-500 dark:text-gray-400">Layout:</label>
        <select id="layout-mode" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs px-3">
          <option value="compact">Compact</option>
          <option value="deck">Deck</option>
        </select>
        <label for="alarm-lead" class="ml-4 text-gray-500 dark:text-gray-400">Alarm:</label>
        <select id="alarm-lead" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs px-3">
          <option value="3">3 min</option>
          <option value="5" selected>5 min</option>
          <option value="10">10 min</option>
          <option value="15">15 min</option>
        </select>
        <label for="alarm-volume" class="ml-4 text-gray-500 dark:text-gray-400">Volume:</label>
        <div class="flex items-center gap-1">
          <input id="alarm-volume" type="range" min="0" max="100" value="80" style="width:80px; vertical-align:middle;">
          <span id="alarm-volume-label" class="text-gray-500 dark:text-gray-400">80%</span>
        </div>
        <label for="sound-preset" class="ml-4 text-gray-500 dark:text-gray-400">Sound:</label>
        <select id="sound-preset" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs px-3">
          <option value="classic">Classic</option>
          <option value="chimes">Chimes</option>
          <option value="retro">Retro</option>
          <option value="pulse">Pulse</option>
        </select>
        <button id="user-test-alarm" class="ml-4 h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition">Test alarm</button>
        <button id="btn-refresh" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition" title="Refresh from cloud">â†» Refresh</button>
      </div>
    </div>

    <!-- Input (admin only) -->
    <div class="mb-4 admin-only">
      <textarea id="input" rows="6" placeholder="Paste the bot schedule message here..." class="w-full rounded-lg border border-gray-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 px-3.5 py-3 text-sm leading-relaxed placeholder:text-gray-400 dark:placeholder:text-gray-600 outline-none focus:border-gray-300 dark:focus:border-neutral-700 transition"></textarea>
    </div>

    <!-- Actions (admin only) -->
    <div class="flex flex-wrap items-center gap-2 mb-4 admin-only">
      <button id="parse" class="h-8 rounded-md bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 text-xs font-medium px-3 hover:bg-gray-800 dark:hover:bg-gray-200 transition">Parse &amp; Save for Everyone</button>
      <button id="test-alarm" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition">Test alarm</button>
      <button id="test-spawn" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition">Test spawn (5s)</button>
      <button id="copy-json" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition">Copy JSON</button>
      <button id="download-ics" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition">Download ICS</button>
      <button id="toggle-layout" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition" title="Switch layout">Deck</button>
      <button id="toggle-timeline" class="h-8 rounded-md border border-gray-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 text-xs text-gray-600 dark:text-gray-300 px-3 hover:bg-gray-50 dark:hover:bg-neutral-800 transition" title="Toggle timeline">Timeline</button>
      <button id="toggle-mute" class="mute-btn w-8 h-8 flex items-center justify-center rounded-lg text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-neutral-800 transition" title="Mute/Unmute sounds">
        <svg id="icon-unmuted" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 010 14.14M15.54 8.46a5 5 0 010 7.07"/></svg>
        <svg id="icon-muted" class="hidden" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>
      </button>
      <span id="toast" class="ml-auto text-xs text-gray-400 dark:text-gray-500 truncate max-w-[200px]"></span>
    </div>

    <!-- Filter bar -->
    <div class="filter-bar mb-4">
      <input id="boss-filter" type="text" placeholder="Filter bosses..." autocomplete="off">
    </div>

    <!-- Timeline -->
    <div id="timeline-section" class="mb-5 hidden"></div>

    <!-- Summary -->
    <div id="summary" class="flex flex-wrap gap-2 mb-5"></div>

    <!-- Sections -->
    <div id="sections"></div>
  </div>

  <!-- Admin Login Modal -->
  <div id="admin-modal" class="admin-overlay hidden">
    <div class="admin-modal">
      <h3 class="text-base font-semibold text-gray-900 dark:text-gray-100 mb-1">Admin Login</h3>
      <p class="text-xs text-gray-400 dark:text-gray-500 mb-4">Enter the admin password to unlock boss management.</p>
      <input id="admin-pw" type="password" class="admin-input" placeholder="Password" autocomplete="off">
      <div id="admin-error" class="admin-error">Incorrect password</div>
      <button id="admin-submit" class="admin-submit">Unlock</button>
      <button id="admin-cancel" class="text-xs text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 mt-3 w-full text-center cursor-pointer bg-transparent border-none">Cancel</button>
    </div>
  </div>

  <!-- Spawn countdown overlay -->
  <div id="spawn-overlay" class="spawn-overlay">
    <div class="spawn-boss-name" id="spawn-boss-name"></div>
    <div class="spawn-number" id="spawn-number"></div>
    <div class="spawn-sub" id="spawn-sub"></div>
  </div>

  <script>
    // =============================================
    // JSONBIN CONFIG
    // =============================================
    const JSONBIN_BIN_ID   = '699a7d7343b1c97be9928d88';
    const JSONBIN_API_KEY  = '$2a$10$cf7uw8DGUik5tPgqyFnLWO2Ms6k.n0VR4w8l6Q6BRiVRcRitqusMe';
    const JSONBIN_BASE_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`;

    const AUTO_REFRESH_MS = 60000;

    // =============================================

    const $ = id => document.getElementById(id);
    const input      = $('input');
    const parseBtn   = $('parse');
    const copyBtn    = $('copy-json');
    const icsBtn     = $('download-ics');
    const testBtn    = $('test-alarm');
    const sectionsEl = $('sections');
    const summaryEl  = $('summary');
    const toastEl    = $('toast');
    const pillEl     = $('status-pill');
    const themeBtn   = $('toggle-theme');
    const layoutBtn  = $('toggle-layout');
    const adminBtn   = $('toggle-admin');
    const adminModal = $('admin-modal');
    const adminPwInput = $('admin-pw');
    const adminSubmit  = $('admin-submit');
    const adminCancel  = $('admin-cancel');
    const adminError   = $('admin-error');
    const adminBadge   = $('admin-badge');
    const bossFilter   = $('boss-filter');
    const timelineSec  = $('timeline-section');
    const muteBtn      = $('toggle-mute');
    const timelineBtn  = $('toggle-timeline');
    const syncDot      = $('sync-dot');
    const syncLabel    = $('sync-label');
    const refreshBtn   = $('btn-refresh');

    let eventsState = [];
    let layout = localStorage.getItem('layout') || 'compact';
    let alarmLeadMin = parseInt(localStorage.getItem('alarmLeadMin') || '5', 10);
    let tickerId = null;
    let autoRefreshId = null;
    let isMuted = localStorage.getItem('muted') === 'true';
    let alarmVolume = parseInt(localStorage.getItem('alarmVolume') || '80', 10) / 100;
    let showTimeline = localStorage.getItem('timeline') === 'true';
    let filterText = '';
    const pinnedBosses = new Set(JSON.parse(localStorage.getItem('pinnedBosses') || '[]'));
    const triggered = new Set();
    const completed = new Set();

    // =============================================
    // JSONBIN: Fetch & Save
    // =============================================
    function setSyncStatus(state, text) {
      syncDot.className = 'sync-dot' + (state === 'syncing' ? ' syncing' : state === 'error' ? ' error' : '');
      syncLabel.textContent = text;
    }

    async function fetchBossesJson() {
      setSyncStatus('syncing', 'Loading...');
      try {
        const res = await fetch(`${JSONBIN_BASE_URL}/latest`, {
          headers: { 'X-Master-Key': JSONBIN_API_KEY }
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        const bosses = data.record;

        if (!Array.isArray(bosses) || !bosses.length || (bosses.length === 1 && bosses[0].name === 'placeholder')) {
          setSyncStatus('ok', 'No schedule yet');
          return;
        }

        const now = Date.now();
        const loaded = bosses
          .map(b => {
            const start = new Date(`${b.date} ${b.start_time}`);
            return {
              boss: b.name,
              date: b.date,
              time: b.start_time,
              dur: b.end_time || '',
              start: start.toISOString()
            };
          })
          .filter(ev => new Date(ev.start).getTime() > now);

        const existingIds = new Set(eventsState.filter(e => e.worldBoss || isFixedSchedule(e.boss)).map(e => evId(e)));
        eventsState = [...eventsState.filter(e => e.worldBoss || isFixedSchedule(e.boss))];
        for (const ev of loaded) {
          const id = evId(ev);
          if (!existingIds.has(id)) eventsState.push(ev);
        }
        eventsState.sort((a, b) => new Date(a.start) - new Date(b.start));

        const lastUpdate = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        setSyncStatus('ok', `Synced ${lastUpdate}`);
        render(eventsState);
        startTicker();
      } catch (e) {
        setSyncStatus('error', 'Sync failed');
        showToast('Could not load boss schedule');
      }
    }

    async function saveBossesToCloud(bossesJson) {
      setSyncStatus('syncing', 'Saving...');
      try {
        const res = await fetch(JSONBIN_BASE_URL, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'X-Master-Key': JSONBIN_API_KEY
          },
          body: JSON.stringify(bossesJson)
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const lastUpdate = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        setSyncStatus('ok', `Saved ${lastUpdate}`);
        return true;
      } catch (e) {
        setSyncStatus('error', 'Save failed');
        showToast('Failed to save to cloud â€” check your API key');
        return false;
      }
    }

    function startAutoRefresh() {
      if (autoRefreshId) clearInterval(autoRefreshId);
      autoRefreshId = setInterval(() => {
        if (!isAdmin) fetchBossesJson();
      }, AUTO_REFRESH_MS);
    }

    refreshBtn.addEventListener('click', () => fetchBossesJson());

    // =============================================
    // Layout & Controls
    // =============================================
    const layoutModeSel = $('layout-mode');
    const alarmLeadSel  = $('alarm-lead');

    if (layoutModeSel) {
      layoutModeSel.value = layout;
      layoutModeSel.addEventListener('change', () => {
        layout = layoutModeSel.value;
        localStorage.setItem('layout', layout);
        setLayout(layout);
      });
    }
    if (alarmLeadSel) {
      alarmLeadSel.value = String(alarmLeadMin);
      alarmLeadSel.addEventListener('change', () => {
        alarmLeadMin = parseInt(alarmLeadSel.value, 10);
        localStorage.setItem('alarmLeadMin', String(alarmLeadMin));
      });
    }

    const alarmVolumeSlider = $('alarm-volume');
    const alarmVolumeLabel  = $('alarm-volume-label');
    if (alarmVolumeSlider && alarmVolumeLabel) {
      alarmVolumeSlider.value = Math.round(alarmVolume * 100);
      alarmVolumeLabel.textContent = Math.round(alarmVolume * 100) + '%';
      alarmVolumeSlider.addEventListener('input', () => {
        alarmVolume = parseInt(alarmVolumeSlider.value, 10) / 100;
        alarmVolumeLabel.textContent = Math.round(alarmVolume * 100) + '%';
        localStorage.setItem('alarmVolume', Math.round(alarmVolume * 100));
      });
    }

    // =============================================
    // Sound Presets
    // =============================================
    const SOUND_PRESETS = {
      classic: {
        beep:  { repeats: 3, type: 'square', freq: 1200, interval: 0.5,  duration: 0.45 },
        tick:  { type: 'sine',     freq: 880,  duration: 0.15, gain: 0.4 },
        spawn: { freqs: [1200,1400,1600], type: 'square',   interval: 0.12, duration: 0.25 }
      },
      chimes: {
        beep:  { repeats: 3, type: 'sine',     freq: 900,  interval: 0.6,  duration: 0.7  },
        tick:  { type: 'sine',     freq: 660,  duration: 0.18, gain: 0.25 },
        spawn: { freqs: [880,1320,1760],  type: 'sine',     interval: 0.16, duration: 0.5  }
      },
      retro: {
        beep:  { repeats: 3, type: 'sawtooth', freq: 1000, interval: 0.35, duration: 0.32 },
        tick:  { type: 'square',   freq: 740,  duration: 0.12, gain: 0.45 },
        spawn: { freqs: [1000,1200,1400], type: 'sawtooth', interval: 0.1,  duration: 0.28 }
      },
      pulse: {
        beep:  { repeats: 3, type: 'sine',     freq: 1500, interval: 0.4,  duration: 0.45 },
        tick:  { type: 'sine',     freq: 1200, duration: 0.08, gain: 0.35 },
        spawn: { freqs: [1500,1500,1500], type: 'sine',     interval: 0.08, duration: 0.12 }
      }
    };

    const presetSel = $('sound-preset');
    let currentPreset = localStorage.getItem('soundPreset') || 'classic';
    if (presetSel) {
      presetSel.value = currentPreset;
      presetSel.addEventListener('change', () => {
        currentPreset = presetSel.value;
        localStorage.setItem('soundPreset', currentPreset);
        showToast('Sound preset: ' + presetSel.options[presetSel.selectedIndex].text);
      });
    }

    $('user-test-alarm').addEventListener('click', () => {
      ensureNotificationPermission();
      playBeep();
      showToast('Test alarm played');
    });

    // =============================================
    // Admin
    // =============================================
    const ADMIN_PASS = 'boss123';
    let isAdmin = sessionStorage.getItem('isAdmin') === 'true';

    function updateAdminUI() {
      $('icon-lock').classList.toggle('hidden', isAdmin);
      $('icon-unlock').classList.toggle('hidden', !isAdmin);
      adminBadge.classList.toggle('hidden', !isAdmin);
      adminBtn.title = isAdmin ? 'Logged in as Admin â€” click to logout' : 'Admin login';
      document.querySelectorAll('.admin-only').forEach(el => {
        el.style.display = isAdmin ? '' : 'none';
      });
    }

    adminBtn.addEventListener('click', () => {
      if (isAdmin) {
        isAdmin = false;
        sessionStorage.removeItem('isAdmin');
        updateAdminUI();
        if (eventsState.length) render(eventsState);
        showToast('Logged out');
        return;
      }
      adminModal.classList.remove('hidden');
      adminPwInput.value = '';
      adminError.style.display = 'none';
      setTimeout(() => adminPwInput.focus(), 100);
    });

    adminSubmit.addEventListener('click', () => {
      if (adminPwInput.value === ADMIN_PASS) {
        isAdmin = true;
        sessionStorage.setItem('isAdmin', 'true');
        adminModal.classList.add('hidden');
        updateAdminUI();
        if (eventsState.length) render(eventsState);
        showToast('Admin mode activated');
      } else {
        adminError.style.display = 'block';
        adminPwInput.select();
      }
    });

    adminPwInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') adminSubmit.click();
      if (e.key === 'Escape') adminCancel.click();
    });
    adminCancel.addEventListener('click', () => adminModal.classList.add('hidden'));

    const showToast = msg => { toastEl.textContent = msg; };

    // =============================================
    // Boss Data
    // =============================================
    const BOSS_LOCATION = {
      'Venatus':          'Corrupted Basin',
      'Clemantis':        'Corrupted Basin',
      'Livera':           'Protector Ruins',
      'Undomiel':         'Secret Laboratory',
      'Araneo':           'Tomb of Tyriosa 1F',
      'General Aquleus':  'Tomb of Tyriosa 2F',
      'Milavy':           'Tomb of Tyriosa 3F',
      'Baron Braudmore':  'Battle Field of Templar',
      'Ringor':           'Battle Field of Templar',
      'Amentis':          'Land of Glory',
      'Viorent':          'Crescent Lake',
      'Saphirus':         'Crescent Lake',
      'Thymele':          'Twilight Hill',
      'Lady Dalia':       'Twilight Hill',
      'Ego':              'Ulan Canyon',
      'Neutro':           'Desert of the Screaming',
      'Wannitas':         'Plateau of Revolution',
      'Metus':            'Plateau of Revolution',
      'Duplican':         'Plateau of Revolution',
      'Shuliar':          'Ruins of War',
      'Larba':            'Ruins of War',
      'Asta':             'Silvergrass Field',
      'Ordo':             'Silvergrass Field',
      'Secreta':          'Silvergrass Field',
      'Supore':           'Silvergrass Field',
      'Chaiflock':        'Silvergrass Field',
      'Benji':            'Barbas',
      'Gareth':           "Deadman's Land District 1F",
      'Titore':           "Deadman's Land District 2F",
      'Catena':           "Deadman's Land District 1F",
      'Roderick':         'Garbana Underground Waterway 1F',
      'Auraq':            'Garbana Underground Waterway 2F',
      'Tumier':           'Garbana Underground Waterway 3F',
      'Icaruthia':        'Kransia - Central Arena',
      'Motti':            'Kransia - Ruined Bastion',
      'Nevaeh':           'Kransia - Skyspire Summit',
    };

    function getBossLocation(name) {
      if (!name) return '';
      return BOSS_LOCATION[name] || Object.entries(BOSS_LOCATION).find(([k]) => k.toLowerCase() === name.toLowerCase())?.[1] || '';
    }

    const h = 3600000;
    const RESPAWN_TIME = {
      'Venatus':          10 * h,
      'Viorent':          10 * h,
      'Lady Dalia':       18 * h,
      'Ego':              21 * h,
      'Livera':           24 * h,
      'Araneo':           24 * h,
      'Undomiel':         24 * h,
      'General Aquleus':  29 * h,
      'Amentis':          29 * h,
      'Baron Braudmore':  32 * h,
      'Gareth':           32 * h,
      'Shuliar':          35 * h,
      'Larba':            35 * h,
      'Catena':           35 * h,
      'Titore':           37 * h,
      'Wannitas':         48 * h,
      'Metus':            48 * h,
      'Duplican':         48 * h,
      'Secreta':          62 * h,
      'Ordo':             62 * h,
      'Asta':             62 * h,
      'Supore':           62 * h,
    };

    const FIXED_SCHEDULE_MAP = {
      'Icaruthia': [ { dow: 2, time: '21:00' }, { dow: 5, time: '21:00' } ],
      'Motti':     [ { dow: 3, time: '19:00' }, { dow: 6, time: '19:00' } ],
      'Nevaeh':    [ { dow: 0, time: '22:00' } ],
    };

    function generateFixedScheduleEvents(daysAhead = 7) {
      const events = [];
      const now = new Date();
      const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      for (let d = 0; d < daysAhead; d++) {
        const day = new Date(start.getFullYear(), start.getMonth(), start.getDate() + d);
        const dow = day.getDay();
        for (const [boss, slots] of Object.entries(FIXED_SCHEDULE_MAP)) {
          for (const slot of slots) {
            if (slot.dow !== dow) continue;
            const [hh, mm] = slot.time.split(':').map(Number);
            const dt = new Date(day.getFullYear(), day.getMonth(), day.getDate(), hh, mm, 0, 0);
            if (dt.getTime() < Date.now()) continue;
            events.push({
              boss,
              start: dt.toISOString(),
              date: dt.toISOString().slice(0,10),
              time: dt.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}),
              dur: '00:30:00',
              worldBoss: false,
            });
          }
        }
      }
      return events;
    }

    const FIXED_SCHEDULE_BOSSES = new Set([
      'Clemantis','Saphirus','Neutro','Thymele','Milavy','Ringor','Roderick','Auraq','Benji','Chaiflock','Tumier',
      'Icaruthia','Motti','Nevaeh'
    ]);

    function isFixedSchedule(name) {
      if (!name) return false;
      return FIXED_SCHEDULE_BOSSES.has(name) || [...FIXED_SCHEDULE_BOSSES].some(k => k.toLowerCase() === name.toLowerCase());
    }

    const WORLD_BOSSES   = ['Ratan', 'Parto', 'Nedra'];
    const WORLD_BOSS_HOURS = [11, 20];

    function generateWorldBossEvents() {
      const events = [];
      const now = Date.now();
      for (let dayOffset = 0; dayOffset < 2; dayOffset++) {
        const base = new Date(now + dayOffset * 864e5);
        for (const hour of WORLD_BOSS_HOURS) {
          const dt = new Date(base.getFullYear(), base.getMonth(), base.getDate(), hour, 0, 0);
          if (dt.getTime() <= now) continue;
          events.push({
            boss: 'World Boss',
            bosses: [...WORLD_BOSSES],
            date: dt.toISOString().slice(0, 10),
            time: dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            dur: '01:00:00',
            start: dt.toISOString(),
            worldBoss: true,
          });
        }
      }
      return events;
    }

    function evId(ev) { return ev.start + '-' + ev.boss; }
    function getRespawnMs(name) {
      return RESPAWN_TIME[name] || Object.entries(RESPAWN_TIME).find(([k]) => k.toLowerCase() === name.toLowerCase())?.[1] || null;
    }

    // =============================================
    // Strip emoji / decoration helpers
    // =============================================
    // Removes :t_rex:, :emoji_name:, and common Unicode emoji from a string
    function stripEmoji(str) {
      return str
        // Remove :shortcode: style emoji (e.g. :t_rex:, :white_check_mark:)
        .replace(/:[a-z0-9_+-]+:/gi, '')
        // Remove Unicode emoji (broad range)
        .replace(/[\u{1F000}-\u{1FFFF}]/gu, '')
        .replace(/[\u{2600}-\u{27BF}]/gu, '')
        .replace(/[\u{FE00}-\u{FEFF}]/gu, '')
        // Remove common dingbats / symbols that appear around boss names
        .replace(/[ðŸ¦–ðŸ¦•ðŸ‰ðŸ²ðŸ—¡ï¸âš”ï¸ðŸ†ðŸ’€â˜ ï¸ðŸ‘¾ðŸ”¥ðŸ’¥]/g, '')
        .trim();
    }

    function cleanBossName(name) {
      return stripEmoji(name)
        // Remove leading/trailing dashes, pipes, underscores, dots
        .replace(/^[\s\-â€“â€”|_.â€¢*#>]+/, '')
        .replace(/[\s\-â€“â€”|_.â€¢*#>]+$/, '')
        .trim();
    }

    // =============================================
    // Kill Boss
    // =============================================
    function killBoss(bossName) {
      const respawnMs = getRespawnMs(bossName);
      if (!respawnMs) return;
      const newStart = new Date(Date.now() + respawnMs).toISOString();
      const ev = eventsState.find(e => e.boss === bossName);
      if (ev) {
        ev.start = newStart;
        triggered.delete(`${ev.start}-${ev.boss}`);
      } else {
        eventsState.push({ boss: bossName, date: newStart.slice(0,10), time: '', dur: '', start: newStart });
      }
      eventsState.sort((a, b) => new Date(a.start) - new Date(b.start));
      const cloudBosses = eventsState
        .filter(e => !e.worldBoss && !isFixedSchedule(e.boss))
        .map(e => ({ name: e.boss, date: e.date, start_time: e.time, end_time: e.dur || '' }));
      saveBossesToCloud(cloudBosses);
      showToast(`${bossName} killed â€” respawns in ${Math.round(respawnMs/3600000)}h`);
      render(eventsState);
    }

    function getInitial(name) { return (name || '?').charAt(0).toUpperCase(); }

    function setPill(text, variant) {
      pillEl.textContent = text;
      pillEl.className = 'text-xs';
      if (variant === 'positive') pillEl.classList.add('text-emerald-500');
      else if (variant === 'negative') pillEl.classList.add('text-rose-500');
      else pillEl.classList.add('text-gray-400', 'dark:text-gray-500');
    }

    function localDateKey(d) {
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    function manualSetTime(bossName) {
      const ev = eventsState.find(e => e.boss === bossName);
      if (!ev) return;
      const existing = document.querySelector(`.manual-row[data-boss="${bossName}"]`);
      if (existing) {
        const inp = existing.querySelector('input');
        const ts = new Date(inp.value);
        if (!inp.value || isNaN(ts)) { existing.remove(); return showToast('Cancelled'); }
        if (ts.getTime() <= Date.now()) return showToast('Time must be in the future');
        ev.start = ts.toISOString();
        triggered.delete(`${ev.start}-${ev.boss}`);
        eventsState.sort((a, b) => new Date(a.start) - new Date(b.start));
        const cloudBosses = eventsState
          .filter(e => !e.worldBoss && !isFixedSchedule(e.boss))
          .map(e => ({ name: e.boss, date: e.date, start_time: e.time, end_time: e.dur || '' }));
        saveBossesToCloud(cloudBosses);
        showToast(`${bossName} set to ${fmtTime(ev.start)}`);
        render(eventsState);
        return;
      }
      const card = document.querySelector(`.manual-trigger[data-boss="${bossName}"]`)?.closest('.boss-card, .deck-card');
      if (!card) return;
      const row = document.createElement('div');
      row.className = 'manual-row flex items-center gap-1 mt-1';
      row.dataset.boss = bossName;
      row.innerHTML = `<input type="datetime-local" class="manual-time-input" step="60"><button class="set-btn" style="padding:2px 6px;font-size:10px;">OK</button>`;
      card.appendChild(row);
      row.querySelector('button').addEventListener('click', () => manualSetTime(bossName));
    }

    function isPinned(name) { return pinnedBosses.has(name); }

    // =============================================
    // Countdown Helpers
    // =============================================
    function fmtCountdown(iso) {
      const d = Math.max(0, new Date(iso).getTime() - Date.now());
      const h = Math.floor(d / 3.6e6);
      const m = Math.floor((d % 3.6e6) / 6e4);
      const s = Math.floor((d % 6e4) / 1e3);
      return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }
    function fmtTime(iso)  { return new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
    function fmtDate(iso)  { return new Date(iso).toLocaleDateString([], { month: 'short', day: 'numeric' }); }

    // =============================================
    // Parse Schedule  â† FIXED: strips :t_rex: and all emoji from boss names
    // =============================================
    function parseSchedule(raw) {
      // Pre-clean: remove all :shortcode: emoji and Unicode emoji from the entire input
      // so they never contaminate boss names
      const cleaned = raw
        .replace(/:[a-z0-9_+-]+:/gi, ' ')
        .replace(/[\u{1F000}-\u{1FFFF}]/gu, ' ')
        .replace(/[\u{2600}-\u{27BF}]/gu, ' ')
        .replace(/[\u{FE00}-\u{FEFF}]/gu, ' ')
        .replace(/[ðŸ¦–ðŸ¦•ðŸ‰ðŸ²ðŸ—¡ï¸âš”ï¸ðŸ†ðŸ’€â˜ ï¸ðŸ‘¾ðŸ”¥ðŸ’¥]/g, ' ');

      const out = [];
      const now = Date.now();

      // Line-by-line parser: handles "Boss â€” date | time (dur)" format
      const lines = cleaned.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      for (const line of lines) {
        const m = line.match(/^(.+?)\s+[â€”\-]+\s+`?(\d{4}-\d{2}-\d{2})\s*\|\s*([0-9: ]+(?:AM|PM))`?\s*(?:\(?(\d{2,3}:\d{2}:\d{2})\)?)?/i);
        if (m) {
          const boss = cleanBossName(m[1]);
          const [, , date, time, dur] = m;
          if (!boss) continue;
          const ts = new Date(`${date} ${time}`);
          if (!isNaN(ts) && ts.getTime() > now) {
            out.push({ boss, date, time: time.trim(), dur: dur || '00:30:00', start: ts.toISOString() });
          }
        }
      }

      // If line-by-line got results, return them
      if (out.length) return out;

      // Fallback: token-based parser (original logic, operates on pre-cleaned text)
      const tokens = cleaned.split(/\s{2,}|\n{2,}/).map(t => t.trim()).filter(Boolean);
      const primary = /^(.+?)\s+[â€”\-]+\s+(\d{4}-\d{2}-\d{2})\s*\|\s*([0-9: ]+(?:AM|PM))\s*\((\d{2,3}:\d{2}:\d{2})\)/i;
      const timeOnlyRe = /([0-9]{1,2}:[0-9]{2}\s*(?:AM|PM))/i;

      for (const t of tokens) {
        let m = t.match(primary);
        if (m) {
          const boss = cleanBossName(m[1]);
          const [, , date, time, dur] = m;
          if (!boss) continue;
          const ts = new Date(`${date} ${time}`);
          if (isNaN(ts)) continue;
          out.push({ boss, date, time: time.trim(), dur, start: ts.toISOString() });
          continue;
        }
        const tlines = t.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        if (!tlines.length) continue;
        let timeLineIndex = tlines.findIndex(l => timeOnlyRe.test(l) || /\|/.test(l));
        let bossPart = null, timePart = null;
        if (timeLineIndex >= 0) {
          bossPart = tlines.slice(0, timeLineIndex).join(', ');
          timePart = tlines[timeLineIndex];
        } else if (tlines.length === 1) {
          const single = tlines[0];
          const tm = single.match(/(.+?)\s+([0-9]{1,2}:[0-9]{2}\s*(?:AM|PM))(?:\s*\((\d{2,3}:\d{2}:\d{2})\))?/i);
          if (tm) { bossPart = tm[1]; timePart = tm[2] + (tm[3] ? ' (' + tm[3] + ')' : ''); }
        } else {
          bossPart = tlines.slice(0, -1).join(', ');
          timePart = tlines[tlines.length - 1];
        }
        if (!bossPart || !timePart) continue;

        let dateStr = null, timeStr = null, dur = null;
        const m2 = timePart.match(/(\d{4}-\d{2}-\d{2})\s*\|\s*([0-9: ]+(?:AM|PM))(?:\s*\((\d{2,3}:\d{2}:\d{2})\))?/i);
        if (m2) { dateStr = m2[1]; timeStr = m2[2]; dur = m2[3] || null; }
        else {
          const m3 = timePart.match(/([0-9: ]+(?:AM|PM))(?:\s*\((\d{2,3}:\d{2}:\d{2})\))?/i);
          if (m3) { timeStr = m3[1]; dur = m3[2] || null; }
        }
        if (!timeStr) continue;

        const names = bossPart.split(/[,/\nÂ·]+/).map(s => cleanBossName(s)).filter(Boolean);
        const lcWorld = WORLD_BOSSES.map(x => x.toLowerCase());
        const isWorldGroup = names.some(n => lcWorld.includes(n.toLowerCase()));

        let startDt = null;
        if (dateStr) {
          startDt = new Date(`${dateStr} ${timeStr}`);
        } else {
          const today = new Date();
          const tm = new Date(`${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')} ${timeStr}`);
          if (isNaN(tm)) continue;
          if (tm.getTime() <= now) tm.setDate(tm.getDate() + 1);
          startDt = tm;
        }
        if (!startDt || isNaN(startDt)) continue;

        if (isWorldGroup) {
          out.push({ boss: 'World Boss', bosses: names, date: startDt.toISOString().slice(0,10), time: startDt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }), dur: dur || '01:00:00', start: startDt.toISOString(), worldBoss: true });
        } else {
          out.push({ boss: names.join(', '), date: startDt.toISOString().slice(0,10), time: startDt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }), dur: dur || '00:30:00', start: startDt.toISOString() });
        }
      }
      return out;
    }

    // =============================================
    // Card Builders
    // =============================================
    function buildCompactCard(ev, label) {
      if (ev.worldBoss || isFixedSchedule(ev.boss)) return buildCompactWorldBossCard(ev.worldBoss ? ev : Object.assign({}, ev, { bosses: [ev.boss] }), label);
      const delta = new Date(ev.start).getTime() - Date.now();
      const urgent = delta <= 5 * 60 * 1000 && delta > 0;
      const soon   = delta <= 15 * 60 * 1000 && delta > 0;
      const cdColor    = urgent ? 'text-rose-500' : soon ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400';
      const ringClass  = urgent ? 'ring-1 ring-rose-200 dark:ring-rose-800' : soon ? 'ring-1 ring-blue-200 dark:ring-blue-900' : '';
      const dateTag    = label === 'Later' ? `<span class="text-[11px] text-gray-400 dark:text-gray-500">${fmtDate(ev.start)}</span>` : '';
      const fallback   = `<div class="boss-img flex items-center justify-center text-xs font-semibold text-gray-500 dark:text-gray-400">${getInitial(ev.boss)}</div>`;
      const loc        = getBossLocation(ev.boss);
      const card = document.createElement('div');
      card.className = `boss-card flex items-center gap-3 px-3 py-2.5 rounded-lg border border-gray-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 ${ringClass}`;
      card.style.position = 'relative';
      const killBtn = (isAdmin && getRespawnMs(ev.boss)) ? `<button class="kill-btn admin-only" data-boss="${ev.boss}">Killed</button>` : '';
      const setBtn  = (isAdmin && !ev.worldBoss && !isFixedSchedule(ev.boss)) ? `<button class="set-btn manual-trigger admin-only" data-boss="${ev.boss}">Set time</button>` : '';
      card.innerHTML = `
        <div class="flex items-center gap-3 w-full">
          <div class="relative flex-shrink-0">${fallback}</div>
          <div class="flex-1 min-w-0 flex flex-col">
            <div class="flex items-center justify-between">
              <div class="min-w-0">
                <div class="text-sm font-medium text-gray-900 dark:text-gray-100 truncate">${ev.boss}</div>
                <div class="text-xs text-gray-400 dark:text-gray-500 mt-1">${fmtTime(ev.start)}${loc ? ` Â· ${loc}` : ''}</div>
                <div class="mt-0">
                  <span class="countdown-mono tabular-nums text-sm font-semibold ${cdColor} whitespace-nowrap" data-cd="${evId(ev)}">${fmtCountdown(ev.start)}</span>
                </div>
              </div>
              <div class="ml-3 text-[11px] text-gray-400 dark:text-gray-500">${dateTag}</div>
            </div>
          </div>
          <div class="flex flex-col items-end justify-center gap-2">${killBtn}${setBtn}</div>
        </div>`;
      card.querySelector('.kill-btn')?.addEventListener('click', () => killBoss(ev.boss));
      card.querySelector('.manual-trigger')?.addEventListener('click', () => manualSetTime(ev.boss));
      return card;
    }

    function buildCompactWorldBossCard(ev, label) {
      const delta = new Date(ev.start).getTime() - Date.now();
      const urgent = delta <= 5 * 60 * 1000 && delta > 0;
      const soon   = delta <= 15 * 60 * 1000 && delta > 0;
      const cdColor   = urgent ? 'text-rose-500' : soon ? 'text-blue-500' : 'text-gray-600 dark:text-gray-400';
      const ringClass = urgent ? 'ring-1 ring-rose-200 dark:ring-rose-800' : soon ? 'ring-1 ring-blue-200 dark:ring-blue-900' : '';
      const dateTag   = label === 'Later' ? `<span class="text-[11px] text-gray-400 dark:text-gray-500">${fmtDate(ev.start)}</span>` : '';
      const names     = ev.bosses || WORLD_BOSSES;
      const title     = names.join(', ');
      const fallback  = `<div class="boss-img flex items-center justify-center text-xs font-semibold text-gray-500 dark:text-gray-400">${getInitial(names[0])}</div>`;
      const singleLoc = names.length === 1 ? getBossLocation(names[0]) : '';
      const card = document.createElement('div');
      card.className = `boss-card flex items-center gap-3 px-3 py-2.5 rounded-lg border border-gray-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 ${ringClass}`;
      card.style.position = 'relative';
      card.innerHTML = `
        <div class="flex items-center gap-3 w-full">
          <div class="relative flex-shrink-0">${fallback}</div>
          <div class="flex-1 min-w-0 flex flex-col">
            <div class="flex items-center justify-between">
              <div class="min-w-0">
                <div class="text-sm font-medium text-gray-900 dark:text-gray-100 truncate whitespace-nowrap">${title}</div>
                <div class="text-xs text-gray-400 dark:text-gray-500 mt-1">${fmtTime(ev.start)}${singleLoc ? ` Â· ${singleLoc}` : ''}</div>
                <div class="mt-0">
                  <span class="countdown-mono tabular-nums text-sm font-semibold ${cdColor} whitespace-nowrap" data-cd="${evId(ev)}">${fmtCountdown(ev.start)}</span>
                </div>
              </div>
              <div class="ml-3 text-[11px] text-gray-400 dark:text-gray-500">${dateTag}</div>
            </div>
          </div>
        </div>`;
      return card;
    }

    function buildDeckCard(ev, label) {
      if (ev.worldBoss || isFixedSchedule(ev.boss)) return buildDeckWorldBossCard(ev.worldBoss ? ev : Object.assign({}, ev, { bosses: [ev.boss] }), label);
      const delta = new Date(ev.start).getTime() - Date.now();
      const urgent = delta <= 5 * 60 * 1000 && delta > 0;
      const soon   = delta <= 15 * 60 * 1000 && delta > 0;
      const cdColor    = urgent ? 'text-rose-500' : soon ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400';
      const stateClass = urgent ? 'urgent' : soon ? 'soon-card' : '';
      const dateTag    = label === 'Later' ? `<div class="text-[10px] text-gray-400 dark:text-gray-500">${fmtDate(ev.start)}</div>` : '';
      const fallback   = `<div class="deck-img flex items-center justify-center text-2xl font-bold text-gray-400 dark:text-gray-500">${getInitial(ev.boss)}</div>`;
      const loc        = getBossLocation(ev.boss);
      const card = document.createElement('div');
      card.className = `deck-card ${stateClass}`;
      card.innerHTML = `
        <div class="relative">${fallback}</div>
        <div class="text-sm font-semibold text-gray-900 dark:text-gray-100 text-center leading-tight truncate w-full px-1">${ev.boss}</div>
        ${loc ? `<div class="text-[12px] text-gray-400 dark:text-gray-500 text-center">${loc}</div>` : ''}
        ${dateTag}
        <div class="text-xs text-gray-400 dark:text-gray-500">${fmtTime(ev.start)}</div>
        <div class="countdown-mono tabular-nums text-base font-bold ${cdColor}" data-cd="${evId(ev)}">${fmtCountdown(ev.start)}</div>
        <div class="flex items-center gap-1.5 flex-wrap justify-center">
          ${(isAdmin && getRespawnMs(ev.boss)) ? `<button class="kill-btn admin-only" data-boss="${ev.boss}">Killed</button>` : ''}
          ${(isAdmin && !ev.worldBoss && !isFixedSchedule(ev.boss)) ? `<button class="set-btn manual-trigger admin-only" data-boss="${ev.boss}">Set time</button>` : ''}
        </div>`;
      card.querySelector('.kill-btn')?.addEventListener('click', () => killBoss(ev.boss));
      card.querySelector('.manual-trigger')?.addEventListener('click', () => manualSetTime(ev.boss));
      return card;
    }

    function buildDeckWorldBossCard(ev, label) {
      const delta = new Date(ev.start).getTime() - Date.now();
      const urgent = delta <= 5 * 60 * 1000 && delta > 0;
      const soon   = delta <= 15 * 60 * 1000 && delta > 0;
      const cdColor    = urgent ? 'text-rose-500' : soon ? 'text-blue-500' : 'text-gray-500 dark:text-gray-400';
      const stateClass = urgent ? 'urgent' : soon ? 'soon-card' : '';
      const dateTag    = label === 'Later' ? `<div class="text-[10px] text-gray-400 dark:text-gray-500">${fmtDate(ev.start)}</div>` : '';
      const names      = ev.bosses || WORLD_BOSSES;
      const title      = names.join(', ');
      const fallback   = `<div class="deck-img flex items-center justify-center text-2xl font-bold text-gray-400 dark:text-gray-500">${getInitial(names[0])}</div>`;
      const singleLoc  = names.length === 1 ? getBossLocation(names[0]) : '';
      const card = document.createElement('div');
      card.className = `deck-card ${stateClass}`;
      card.innerHTML = `
        <div class="relative">${fallback}</div>
        <div class="text-sm font-semibold text-gray-900 dark:text-gray-100 text-center leading-tight truncate w-full px-1 whitespace-nowrap">${title}</div>
        ${singleLoc ? `<div class="text-[12px] text-gray-400 dark:text-gray-500 text-center w-full">${singleLoc}</div>` : ''}
        ${dateTag}
        <div class="text-xs text-gray-400 dark:text-gray-500">${fmtTime(ev.start)}</div>
        <div class="countdown-mono tabular-nums text-base font-bold ${cdColor}" data-cd="${evId(ev)}">${fmtCountdown(ev.start)}</div>`;
      return card;
    }

    function getDisplayName(ev) { return ev.bosses ? ev.bosses.join(', ') : ev.boss; }

    function matchesFilter(ev) {
      if (!filterText) return true;
      const q = filterText.toLowerCase();
      return getDisplayName(ev).toLowerCase().includes(q) || getBossLocation(ev.boss || '').toLowerCase().includes(q);
    }

    function sortWithPins(items) {
      return [...items].sort((a, b) => {
        const aP = isPinned(a.boss) || (a.bosses && a.bosses.some(n => isPinned(n)));
        const bP = isPinned(b.boss) || (b.bosses && b.bosses.some(n => isPinned(n)));
        if (aP && !bP) return -1;
        if (!aP && bP) return 1;
        return new Date(a.start) - new Date(b.start);
      });
    }

    // =============================================
    // Render
    // =============================================
    function render(events) {
      sectionsEl.innerHTML = '';
      summaryEl.innerHTML  = '';
      if (!events.length) { setPill('No events', 'negative'); return; }
      const filtered = events.filter(matchesFilter);
      if (!filtered.length) { setPill('No matches', 'negative'); renderTimeline(events); return; }

      const todayKey = localDateKey(new Date());
      const tmrwKey  = localDateKey(new Date(Date.now() + 864e5));
      const buckets  = { Today: [], Tomorrow: [], Later: [] };

      for (const ev of filtered) {
        const k = localDateKey(new Date(ev.start));
        if (k === todayKey) buckets.Today.push(ev);
        else if (k === tmrwKey) buckets.Tomorrow.push(ev);
        else buckets.Later.push(ev);
      }

      for (const [label, unsorted] of Object.entries(buckets)) {
        const items = sortWithPins(unsorted);
        if (!items.length) continue;
        const section = document.createElement('div');
        section.className = 'mb-5';
        const header = document.createElement('div');
        header.className = 'flex items-baseline justify-between mb-2 px-1';
        header.innerHTML = `<span class="text-xs font-semibold uppercase tracking-wider text-gray-400 dark:text-gray-500">${label}</span><span class="text-xs text-gray-400 dark:text-gray-600">${items.length}</span>`;
        section.appendChild(header);
        if (layout === 'deck') {
          const scroll = document.createElement('div');
          scroll.className = 'deck-scroll';
          for (const ev of items) scroll.appendChild(buildDeckCard(ev, label));
          section.appendChild(scroll);
        } else {
          const grid = document.createElement('div');
          grid.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3';
          for (const ev of items) grid.appendChild(buildCompactCard(ev, label));
          section.appendChild(grid);
        }
        sectionsEl.appendChild(section);
      }

      const upcoming = events.filter(ev => new Date(ev.start).getTime() > Date.now());
      const next     = upcoming.length ? upcoming[0] : null;
      const nextName = next ? getDisplayName(next) : '';
      summaryEl.innerHTML = `
        <span class="text-xs text-gray-400 dark:text-gray-500">${filtered.length} event${filtered.length===1?'':'s'}${filterText ? ' (filtered)' : ''}</span>
        ${next ? `<span class="text-xs text-gray-400 dark:text-gray-500">Â· Next: <span class="text-gray-600 dark:text-gray-300 font-medium">${nextName}</span> in ${fmtCountdown(next.start)}</span>` : ''}`;
      setPill(filtered.length + ' active', 'positive');
      renderTimeline(events);
    }

    function renderTimeline(events) {
      timelineSec.innerHTML = '';
      if (!showTimeline || !events.length) { timelineSec.classList.add('hidden'); return; }
      timelineSec.classList.remove('hidden');
      const now = Date.now();
      const upcoming = events.filter(ev => new Date(ev.start).getTime() > now);
      if (!upcoming.length) return;
      const startMs = now;
      const endMs   = Math.max(...upcoming.map(ev => new Date(ev.start).getTime()));
      const rangeMs = endMs - startMs;
      if (rangeMs <= 0) return;
      const header = document.createElement('div');
      header.className = 'flex items-baseline justify-between mb-2 px-1';
      header.innerHTML = `<span class="text-xs font-semibold uppercase tracking-wider text-gray-400 dark:text-gray-500">Timeline</span>`;
      timelineSec.appendChild(header);
      const wrap = document.createElement('div');
      wrap.className = 'timeline-wrap';
      const bar = document.createElement('div');
      bar.className = 'timeline-bar';
      const nowMarker = document.createElement('div');
      nowMarker.className = 'timeline-now';
      nowMarker.style.left = '0%';
      bar.appendChild(nowMarker);
      const nowLabel = document.createElement('div');
      nowLabel.className = 'timeline-now-label';
      nowLabel.style.left = '0%';
      nowLabel.textContent = 'Now';
      bar.appendChild(nowLabel);
      for (const ev of upcoming) {
        const pct   = ((new Date(ev.start).getTime() - startMs) / rangeMs) * 100;
        const delta = new Date(ev.start).getTime() - now;
        const urgent = delta <= 5 * 60 * 1000;
        const soon   = delta <= 15 * 60 * 1000;
        const name   = getDisplayName(ev);
        const marker = document.createElement('div');
        marker.className = `timeline-marker${urgent ? ' urgent-marker' : soon ? ' soon-marker' : ''}`;
        marker.style.left = pct + '%';
        marker.textContent = name.charAt(0);
        marker.title = `${name} â€” ${fmtTime(ev.start)} (${fmtCountdown(ev.start)})`;
        bar.appendChild(marker);
        const lbl = document.createElement('div');
        lbl.className = 'timeline-label';
        lbl.style.left = pct + '%';
        lbl.textContent = name.length > 10 ? name.slice(0, 9) + 'â€¦' : name;
        bar.appendChild(lbl);
      }
      wrap.appendChild(bar);
      timelineSec.appendChild(wrap);
    }

    function updateCountdowns() {
      for (const ev of eventsState) {
        const els   = document.querySelectorAll(`[data-cd="${evId(ev)}"]`);
        const cd    = fmtCountdown(ev.start);
        const delta = new Date(ev.start).getTime() - Date.now();
        const urgent = delta <= 5 * 60 * 1000 && delta > 0;
        const soon   = delta <= 15 * 60 * 1000 && delta > 0;
        for (const el of els) {
          el.textContent = cd;
          el.classList.remove('text-rose-500','text-blue-500','text-gray-600','text-gray-500');
          if (urgent) el.classList.add('text-rose-500');
          else if (soon) el.classList.add('text-blue-500');
          else el.classList.add('text-gray-600');
          const card = el.closest('.boss-card') || el.closest('.deck-card');
          if (card) {
            card.classList.remove('ring-1','ring-rose-200','dark:ring-rose-800','ring-blue-200','dark:ring-blue-900','urgent','soon-card');
            if (card.classList.contains('deck-card')) {
              if (urgent) card.classList.add('urgent');
              else if (soon) card.classList.add('soon-card');
            } else {
              if (urgent) card.classList.add('ring-1','ring-rose-200','dark:ring-rose-800');
              else if (soon) card.classList.add('ring-1','ring-blue-200','dark:ring-blue-900');
            }
          }
        }
      }
      const upcoming = eventsState.filter(ev => new Date(ev.start).getTime() > Date.now());
      const next = upcoming.length ? upcoming[0] : null;
      if (next) {
        summaryEl.innerHTML = `
          <span class="text-xs text-gray-400 dark:text-gray-500">${eventsState.length} event${eventsState.length===1?'':'s'}</span>
          <span class="text-xs text-gray-400 dark:text-gray-500">\u00b7 Next: <span class="text-gray-600 dark:text-gray-300 font-medium">${getDisplayName(next)}</span> in ${fmtCountdown(next.start)}</span>`;
      }
    }

    function ensureNotificationPermission() {
      if (!('Notification' in window)) return false;
      if (Notification.permission === 'granted') return true;
      if (Notification.permission === 'denied') return false;
      Notification.requestPermission();
      return false;
    }

    function playBeep(repeats = 3) {
      if (isMuted) return;
      try {
        const cfg = Object.assign({}, (SOUND_PRESETS[currentPreset] || SOUND_PRESETS.classic).beep);
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        for (let i = 0; i < (cfg.repeats || repeats); i++) {
          const osc = ctx.createOscillator(), gain = ctx.createGain();
          const t = ctx.currentTime + i * (cfg.interval || 0.5);
          osc.type = cfg.type || 'square'; osc.frequency.value = cfg.freq || 1200;
          gain.gain.setValueAtTime(alarmVolume * (cfg.gain || 1), t);
          gain.gain.exponentialRampToValueAtTime(0.0001, t + (cfg.duration || 0.45));
          osc.connect(gain).connect(ctx.destination); osc.start(t); osc.stop(t + (cfg.duration || 0.45));
        }
      } catch (e) {}
    }

    function triggerAlarm(ev) {
      const name = getDisplayName(ev);
      const msg  = `${name} spawning in ${alarmLeadMin} min (${fmtTime(ev.start)})`;
      showToast(msg); setPill('Alarm: ' + name, 'negative'); playBeep();
      if (Notification.permission === 'granted') new Notification('Boss Timer', { body: msg });
    }

    function checkAlarms() {
      const now = Date.now();
      for (const ev of eventsState) {
        const id    = `${ev.start}-${ev.boss}`;
        if (triggered.has(id)) continue;
        const delta = new Date(ev.start).getTime() - now;
        if (delta <= alarmLeadMin * 60 * 1000 && delta > 0) { triggered.add(id); triggerAlarm(ev); }
      }
      checkSpawnCountdown();
    }

    // =============================================
    // Spawn Countdown Overlay
    // =============================================
    let spawnCountdownActive = null;
    let spawnedEvent = null;
    let lastSpawnSecond = -1;
    const spawnOverlay    = $('spawn-overlay');
    const spawnBossNameEl = $('spawn-boss-name');
    const spawnSubEl      = $('spawn-sub');

    function playTick() {
      if (isMuted) return;
      try {
        const cfg = (SOUND_PRESETS[currentPreset] || SOUND_PRESETS.classic).tick || {};
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator(), gain = ctx.createGain();
        osc.type = cfg.type || 'sine'; osc.frequency.value = cfg.freq || 880;
        gain.gain.setValueAtTime((cfg.gain || 0.4) * alarmVolume, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + (cfg.duration || 0.15));
        osc.connect(gain).connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime + (cfg.duration || 0.2));
      } catch (e) {}
    }

    function playSpawnSound() {
      if (isMuted) return;
      try {
        const cfg = (SOUND_PRESETS[currentPreset] || SOUND_PRESETS.classic).spawn || {};
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        (cfg.freqs || [1200,1400,1600]).forEach((f, i) => {
          const osc = ctx.createOscillator(), gain = ctx.createGain();
          const t = ctx.currentTime + i * (cfg.interval || 0.12);
          osc.type = cfg.type || 'square'; osc.frequency.value = f;
          gain.gain.setValueAtTime(alarmVolume * (cfg.gain || 1), t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + (cfg.duration || 0.25));
          osc.connect(gain).connect(ctx.destination); osc.start(t); osc.stop(t + (cfg.duration || 0.3));
        });
      } catch (e) {}
    }

    function checkSpawnCountdown() {
      const now = Date.now();
      let nearest = null, nearestDelta = Infinity;
      for (const ev of eventsState) {
        const delta = new Date(ev.start).getTime() - now;
        if (delta > -3000 && delta < 6000 && Math.abs(delta) < nearestDelta) { nearest = ev; nearestDelta = Math.abs(delta); }
      }
      if (!nearest && spawnedEvent) {
        if (now - new Date(spawnedEvent.start).getTime() < 3000) { nearest = spawnedEvent; }
        else { spawnOverlay.classList.remove('active'); spawnedEvent = spawnCountdownActive = null; lastSpawnSecond = -1; return; }
      }
      if (!nearest) {
        if (spawnCountdownActive) { spawnOverlay.classList.remove('active'); spawnCountdownActive = null; lastSpawnSecond = -1; }
        return;
      }
      const delta = new Date(nearest.start).getTime() - now;
      const sec   = Math.ceil(delta / 1000);
      const name  = getDisplayName(nearest);
      if (!spawnOverlay.classList.contains('active')) spawnOverlay.classList.add('active');
      spawnCountdownActive = nearest;
      spawnBossNameEl.textContent = name;
      if (sec <= 0) {
        if (lastSpawnSecond !== 0) {
          spawnedEvent = nearest;
          const numEl = spawnOverlay.querySelector('.spawn-number');
          numEl.className = 'spawn-number spawned'; numEl.textContent = 'SPAWNED!';
          spawnSubEl.textContent = 'Go go go!'; playSpawnSound(); lastSpawnSecond = 0;
        }
      } else if (sec !== lastSpawnSecond && sec <= 5) {
        const numEl = spawnOverlay.querySelector('.spawn-number');
        const clone = numEl.cloneNode(false);
        clone.className = 'spawn-number'; clone.textContent = sec;
        numEl.replaceWith(clone);
        spawnSubEl.textContent = sec === 1 ? 'Get ready!' : 'Spawning soon...';
        playTick(); lastSpawnSecond = sec;
      }
    }

    function prunePastEvents() {
      const now = Date.now();
      const remaining = [];
      let changed = false;
      for (const ev of eventsState) {
        if (new Date(ev.start).getTime() <= now) { completed.add(ev.boss); changed = true; continue; }
        remaining.push(ev);
      }
      if (changed) eventsState = remaining;
      return changed;
    }

    function startTicker() {
      if (tickerId) clearInterval(tickerId);
      tickerId = setInterval(() => {
        checkSpawnCountdown();
        const pruned = prunePastEvents();
        if (pruned) render(eventsState);
        else updateCountdowns();
        checkAlarms();
      }, 1000);
    }

    // =============================================
    // Parse Button
    // =============================================
    parseBtn.addEventListener('click', async () => {
      const now = Date.now();
      const parsed = parseSchedule(input.value)
        .filter(ev => new Date(ev.start).getTime() > now && !completed.has(ev.boss))
        .sort((a, b) => new Date(a.start) - new Date(b.start));

      if (!parsed.length) return showToast('No valid events found â€” check your paste format');

      const bossesJson = parsed.map(ev => ({
        name: ev.boss,
        date: ev.date,
        start_time: ev.time,
        end_time: ev.dur || ''
      }));

      const saved = await saveBossesToCloud(bossesJson);
      if (!saved) return;

      showToast(`âœ“ Saved ${parsed.length} bosses for everyone!`);

      const worldFixed = eventsState.filter(e => e.worldBoss || isFixedSchedule(e.boss));
      eventsState = [...worldFixed, ...parsed];
      eventsState.sort((a, b) => new Date(a.start) - new Date(b.start));

      render(eventsState);
      ensureNotificationPermission();
      startTicker();

      try { input.parentElement.style.display = 'none'; } catch (e) {}
    });

    // =============================================
    // Other Button Listeners
    // =============================================
    copyBtn.addEventListener('click', async () => {
      if (!eventsState.length) return showToast('No events loaded');
      await navigator.clipboard.writeText(JSON.stringify(eventsState, null, 2));
      showToast('Copied to clipboard');
    });

    icsBtn.addEventListener('click', () => {
      if (!eventsState.length) return showToast('No events loaded');
      const lines = ['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//Boss Timer//EN'];
      for (const ev of eventsState) {
        const stamp = new Date().toISOString().replace(/[-:]/g,'').replace(/\.\d{3}Z$/,'Z');
        const start = new Date(ev.start).toISOString().replace(/[-:]/g,'').replace(/\.\d{3}Z$/,'Z');
        lines.push('BEGIN:VEVENT',`UID:${start}-${ev.boss.replace(/\s+/g,'-')}`,`DTSTAMP:${stamp}`,`DTSTART:${start}`,`DTEND:${start}`,`SUMMARY:${ev.boss}`,'END:VEVENT');
      }
      lines.push('END:VCALENDAR');
      const blob = new Blob([lines.join('\r\n')], { type: 'text/calendar' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'boss-timers.ics'; a.click(); URL.revokeObjectURL(a.href);
      showToast('Downloaded');
    });

    testBtn.addEventListener('click', () => { ensureNotificationPermission(); playBeep(); showToast('Test played'); });

    $('test-spawn').addEventListener('click', () => {
      const spawnAt = new Date(Date.now() + 5000);
      const testEv  = { boss: 'World Boss', bosses: ['Ratan','Parto','Nedra'], date: spawnAt.toISOString().slice(0,10), time: spawnAt.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}), dur:'01:00:00', start: spawnAt.toISOString(), worldBoss: true };
      eventsState.push(testEv);
      eventsState.sort((a, b) => new Date(a.start) - new Date(b.start));
      render(eventsState); startTicker();
      showToast('Test boss spawning in 5 seconds...');
    });

    // =============================================
    // Layout / Mute / Filter / Timeline
    // =============================================
    function setLayout(mode) {
      layout = mode; localStorage.setItem('layout', mode);
      layoutBtn.textContent = mode === 'deck' ? 'Compact' : 'Deck';
      if (eventsState.length) render(eventsState);
    }
    layoutBtn.addEventListener('click', () => setLayout(layout === 'deck' ? 'compact' : 'deck'));
    setLayout(layout);

    function updateMuteUI() {
      $('icon-unmuted').classList.toggle('hidden', isMuted);
      $('icon-muted').classList.toggle('hidden', !isMuted);
      muteBtn.title = isMuted ? 'Unmute sounds' : 'Mute sounds';
    }
    muteBtn.addEventListener('click', () => { isMuted = !isMuted; localStorage.setItem('muted', isMuted); updateMuteUI(); showToast(isMuted ? 'Sounds muted' : 'Sounds unmuted'); });
    updateMuteUI();

    bossFilter.addEventListener('input', () => { filterText = bossFilter.value.trim(); if (eventsState.length) render(eventsState); });

    function updateTimelineUI() {
      timelineBtn.textContent = showTimeline ? 'Hide Timeline' : 'Timeline';
      if (eventsState.length) render(eventsState);
    }
    timelineBtn.addEventListener('click', () => { showTimeline = !showTimeline; localStorage.setItem('timeline', showTimeline); updateTimelineUI(); });
    updateTimelineUI();

    // =============================================
    // Theme
    // =============================================
    function applyTheme(mode) {
      document.documentElement.classList.toggle('dark', mode === 'dark');
      $('icon-sun').classList.toggle('hidden', mode !== 'dark');
      $('icon-moon').classList.toggle('hidden', mode === 'dark');
      localStorage.setItem('theme', mode);
    }
    themeBtn.addEventListener('click', () => applyTheme(document.documentElement.classList.contains('dark') ? 'light' : 'dark'));
    applyTheme(localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'));

    // =============================================
    // Init
    // =============================================
    updateAdminUI();

    (function initStaticEvents() {
      const wb    = generateWorldBossEvents();
      const fixed = generateFixedScheduleEvents(7);
      const existing = new Set(eventsState.map(evId));
      for (const ev of [...wb, ...fixed]) {
        if (!existing.has(evId(ev))) { eventsState.push(ev); existing.add(evId(ev)); }
      }
      eventsState.sort((a, b) => new Date(a.start) - new Date(b.start));
    })();

    fetchBossesJson().then(() => {
      ensureNotificationPermission();
      startTicker();
      startAutoRefresh();
    });

    document.addEventListener('wheel', e => {
      const el = e.target.closest && e.target.closest('.deck-scroll');
      if (!el || e.deltaY === 0) return;
      el.scrollLeft += e.deltaY; e.preventDefault();
    }, { passive: false });

    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js').catch(() => {});
  </script>
</body>
</html>